# 중급

## 1) 직각삼각형
def find_max_pythagorean_perimeter(N):
    from collections import defaultdict
    from math import gcd

    triangle_counts = defaultdict(int)

    for m in range(2, int(N**0.5) + 1):
        for n in range(1, m):
            if (m - n) % 2 == 1 and gcd(m, n) == 1:
                a = m**2 - n**2
                b = 2 * m * n
                c = m**2 + n**2
                perimeter = a + b + c

                if perimeter > N:
                    break

                k = 1
                while k * perimeter <= N:
                    triangle_counts[k * perimeter] += 1
                    k += 1

    max_p = max(triangle_counts, key=lambda x: (triangle_counts[x], -x), default=0)
    return max_p, triangle_counts[max_p]

N = int(input())
result = find_max_pythagorean_perimeter(N)
print(result[0], result[1])

## 2) 좋은 배열	
def is_good_array(N, a):
    positions = {}
    
    for index, value in enumerate(a):
        if value not in positions:
            positions[value] = []
        positions[value].append(index)
        
        if len(positions[value]) > 2:
            return "NO"
    
    for value, indices in positions.items():
        if len(indices) == 2 and indices[0] % 2 == indices[1] % 2:
            return "NO"
    
    return "YES"

N = int(input())
a = list(map(int, input().split()))
print(is_good_array(N, a))

## 3) 동네 한 바퀴
from collections import defaultdict
import sys
sys.setrecursionlimit(10**6)

def can_return_to_start(N, M, roads):
    graph = defaultdict(list)
    reverse_graph = defaultdict(list)
    
    for s, e in roads:
        graph[s].append(e)
        reverse_graph[e].append(s)
    
    def dfs(node, visited, stack):
        visited[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                dfs(neighbor, visited, stack)
        stack.append(node)
    
    def reverse_dfs(node, visited, component):
        visited[node] = True
        component.append(node)
        for neighbor in reverse_graph[node]:
            if not visited[neighbor]:
                reverse_dfs(neighbor, visited, component)
    
    visited = [False] * (N + 1)
    stack = []
    
    for i in range(1, N + 1):
        if not visited[i]:
            dfs(i, visited, stack)
    
    visited = [False] * (N + 1)
    scc = []
    
    while stack:
        node = stack.pop()
        if not visited[node]:
            component = []
            reverse_dfs(node, visited, component)
            scc.append(component)
    
    for component in scc:
        if 1 in component:
            reachable = set(component)
            sub_visited = [False] * (N + 1)
            
            def dfs_check(node):
                sub_visited[node] = True
                for neighbor in graph[node]:
                    if neighbor not in reachable or sub_visited[neighbor]:
                        continue
                    dfs_check(neighbor)
            
            dfs_check(1)
            
            return "YES" if all(sub_visited[node] for node in reachable) and len(reachable) > 1 else "NO"
    
    return "NO"

N, M = map(int, input().split())
roads = [tuple(map(int, input().split())) for _ in range(M)]
print(can_return_to_start(N, M, roads))

## 4) 이웃

## 5) 일차원 세계의 섬	

## 6) 나이트 자리 바꾸기	
from collections import deque

knight_moves = [
    (-1, 2), (1, 2), (-2, 1), (-2, -1),
    (2, -1), (2, 1), (-1, -2), (1, -2)
]

def is_valid(x, y):
    return 0 <= x < 3 and 0 <= y < 3

def can_swap_knights(board):
    initial_state = tuple(tuple(row) for row in board)
    goal_state = tuple(tuple(2 if cell == 1 else 1 if cell == 2 else 0 for cell in row) for row in board)
    
    queue = deque([initial_state])
    visited = set()
    visited.add(initial_state)
    
    while queue:
        current_state = queue.popleft()
        if current_state == goal_state:
            return "possible"
        
        for x in range(3):
            for y in range(3):
                if current_state[x][y] in (1, 2):
                    knight = current_state[x][y]
                    for dx, dy in knight_moves:
                        nx, ny = x + dx, y + dy
                        if is_valid(nx, ny) and current_state[nx][ny] == 0:
                            new_state = [list(row) for row in current_state]
                            new_state[x][y] = 0
                            new_state[nx][ny] = knight
                            new_state_tuple = tuple(tuple(row) for row in new_state)
                            if new_state_tuple not in visited:
                                visited.add(new_state_tuple)
                                queue.append(new_state_tuple)
    return "impossible"

def solve_chess_puzzle():
    board = []
    for _ in range(3):
        row = list(map(int, input().strip()))
        board.append(row)
    result = can_swap_knights(board)
    print(result)

solve_chess_puzzle()

## 7) 카드 게임	

## 8) 직선으로 땅 나누기	
def min_lines_needed(n):
    k = 0
    while True:
        regions = (k * (k + 1)) // 2 + 1
        if regions >= n: 
            return k
        k += 1

n = int(input())
print(min_lines_needed(n))

## 9) 부분행렬
def find_submatrix_with_sum(n, m, x, matrix):
    for r1 in range(n):
        for r2 in range(r1, n):
            for c1 in range(m):
                for c2 in range(c1, m):
                    total = 0
                    for i in range(r1, r2 + 1):
                        for j in range(c1, c2 + 1):
                            total += matrix[i][j]
                    if total == x:
                        return "YES"
    return "NO"

n, m, x = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(n)]

print(find_submatrix_with_sum(n, m, x, matrix))

## 10) Anti Multiply Array
def find_indices_with_equal_products(n, arr):
    product_map = {}

    for i in range(n):
        for j in range(i + 1, n):
            product = arr[i] * arr[j]
            
            if product in product_map:
                a, b = product_map[product]
                if len({a, b, i, j}) == 4:
                    return "YES"
            else:
                product_map[product] = (i, j)
    
    return "NO"

n = int(input())
arr = list(map(int, input().split()))

print(find_indices_with_equal_products(n, arr))

## 11) 전설의 도둑
from collections import deque

def min_warp_count(k, n):
    MAX_POS = 100000
    visited = [False] * (MAX_POS + 1)
    
    queue = deque([(k, 0)])
    visited[k] = True

    while queue:
        current, count = queue.popleft()

        if current == n:
            return count

        next_positions = [current + 3, current - 1, current * 2]

        for next_pos in next_positions:
            if 0 <= next_pos <= MAX_POS and not visited[next_pos]:
                visited[next_pos] = True
                queue.append((next_pos, count + 1))

k, n = map(int, input().split())

print(min_warp_count(k, n))

## 12) 팔찌
def are_bracelets_same(bracelet1, bracelet2):
    if len(bracelet1) != len(bracelet2):
        return "NO"
    
    extended_bracelet = bracelet1 * 2
    
    if bracelet2 in extended_bracelet:
        return "YES"
    else:
        return "NO"

bracelet1 = input().strip()
bracelet2 = input().strip()

print(are_bracelets_same(bracelet1, bracelet2))
